name: 'Commit or Rewrite'
description: 'Smart GitHub Action that creates or amends commits. Rewrites HEAD commit if it has matching ID, otherwise creates new commit. All commits are signed via GitHub API.'
inputs:
  commit_message:
    description: 'Commit message (can be multiline)'
    required: true
  id:
    description: 'Unique identifier for amending commits (e.g., changelog-update)'
    required: true
  branch:
    description: 'Target branch (auto-detects current branch if not specified)'
    required: false
    default: ''
  files:
    description: 'Files to commit (newline-separated). If empty, commits all changes'
    required: false
    default: ''
  github_token:
    description: 'GitHub token for API operations'
    required: false
    default: ${{ github.token }}

runs:
  using: 'composite'
  steps:
    - name: Detect branch if not specified
      id: detect-branch
      shell: bash
      env:
        INPUT_BRANCH: ${{ inputs.branch }}
      run: |
        if [ -n "$INPUT_BRANCH" ]; then
          echo "Using specified branch: $INPUT_BRANCH"
          echo "branch=$INPUT_BRANCH" >> $GITHUB_OUTPUT
        else
          # Auto-detect current branch
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "Auto-detected branch: $CURRENT_BRANCH"
          echo "branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
        fi

    - name: Check for changes
      id: check-changes
      shell: bash
      env:
        FILES: ${{ inputs.files }}
      run: |
        # Get files list - use provided files or get all changed files
        if [ -z "$FILES" ]; then
          echo "No files specified, getting all changed files"
          FILES=$(git diff --name-only HEAD; git diff --cached --name-only HEAD; git ls-files --others --exclude-standard)
        fi

        # Process files list (keep newline-separated for commit-action)
        FILES_LIST=$(echo "$FILES" | sort -u)

        # Store files list for later use
        echo "files_list=$FILES_LIST" >> $GITHUB_OUTPUT

        # Check if there are any changes
        if [ -z "$FILES_LIST" ]; then
          echo "No files to commit"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Changes detected"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Check if HEAD has matching trailer
      if: steps.check-changes.outputs.has_changes == 'true'
      id: check-trailer
      shell: bash
      env:
        TRAILER_ID: ${{ inputs.id }}
      run: |
        # Check if HEAD commit has our trailer using git interpret-trailers
        COMMIT_MSG=$(git log -1 --format=%B)
        TRAILER_VALUE=$(echo "$COMMIT_MSG" | git interpret-trailers --parse | grep "^X-Commit-Rewrite-ID:" | cut -d' ' -f2- || true)

        if [ "$TRAILER_VALUE" = "$TRAILER_ID" ]; then
          echo "HEAD has matching trailer (X-Commit-Rewrite-ID: $TRAILER_ID)"
          echo "should_reset=true" >> $GITHUB_OUTPUT
          # Store parent SHA for later use
          PARENT_SHA=$(git rev-parse HEAD~1)
          echo "parent_sha=$PARENT_SHA" >> $GITHUB_OUTPUT
        else
          echo "HEAD does not have matching trailer"
          echo "should_reset=false" >> $GITHUB_OUTPUT
        fi

    - name: Reset to parent if needed
      if: steps.check-changes.outputs.has_changes == 'true' && steps.check-trailer.outputs.should_reset == 'true'
      shell: bash
      env:
        PARENT_SHA: ${{ steps.check-trailer.outputs.parent_sha }}
      run: |
        echo "Resetting to parent commit: $PARENT_SHA"
        # Reset local repository to parent commit
        git reset --hard "$PARENT_SHA"

    - name: Create commit with trailer
      if: steps.check-changes.outputs.has_changes == 'true'
      uses: suzuki-shunsuke/commit-action@v0.0.11
      with:
        fail_on_self_push: false
        github_token: ${{ inputs.github_token }}
        commit_message: |
          ${{ inputs.commit_message }}

          X-Commit-Rewrite-ID: ${{ inputs.id }}
        branch: ${{ steps.detect-branch.outputs.branch }}
        files: ${{ steps.check-changes.outputs.files_list }}

    - name: Sync local git state with remote
      if: steps.check-changes.outputs.has_changes == 'true'
      shell: bash
      env:
        BRANCH: ${{ steps.detect-branch.outputs.branch }}
      run: |
        echo "Syncing local git state with remote branch: $BRANCH"
        # Fetch the latest state of the branch
        git fetch origin "$BRANCH"

        # Reset the current branch to match remote
        git reset --hard "origin/$BRANCH"
